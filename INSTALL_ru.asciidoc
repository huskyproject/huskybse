Установка Husky
===============

Оглавление
----------

  1 Введение
  2 Установка с использованием универсальных мейкфайлов
    2.1 Конфигурирование сборки с помощью huskymak.cfg
    2.2 Установка Husky в дистрибутивах Linux c пакетным менеджером rpm
    2.3 Установка Husky в других ОС типа UNIX
  3 Установка Husky с мейкфайлами старого образца
    3.1 Обзор
    3.2 Получение исходников
    3.3 Список платформ, поддерживаемых мейкфайлами старого образца
    3.4 Компиляция
    3.5 Установка

1 Введение
==========

*Husky* - это набор программ для обработки приходящих сообщений и файлов в
соответствии со стандартами Fidonet. Здесь вы узнаете как установить Husky.
Для установки можно использовать мейкфайлы двух типов. Универсальные
мейкфайлы позволяют выполнять установку в разных операционных системах за
счёт наличия конфигурационного файла `huskymak.cfg`. Мейкфайлы второго типа
(старого образца) предназначены для конкретной операционной системы.

Номера версий программ Husky состоят из трёх целых чисел, разделённых
точками, например,

  1.9.20210827

Здесь последнее число - это дата внесения последнего изменения в исходный
код программы. Дата состоит из последовательно записанных года, месяца и дня.

2 Установка с использованием универсальных мейкфайлов
=====================================================

Предполагается, что у вас установлен GNU make версии 3.82 или новее. Для
сборки пакетов перловых утилит надо установить `Module::Build`. Возможно,
соответствующий пакет в вашем дистрибутиве называется `perl-Module-Build`.
Кроме того, надо будет установить `git`. В FreeBSD дополнительно потребуется
установить `gnugrep`. Для конфигурирования сборки с помощью универсальных
мейкфайлов служит файл *huskymak.cfg*.

2.1 Конфигурирование сборки с помощью huskymak.cfg
--------------------------------------------------

Конфигурационный файл `huskymak.cfg` содержит настройки, используемые во время
сборки программ Husky. Вы можете изменять эти настройки в соответствии с вашими
потребностями. Все строки, начинающиеся с символа `#`, - это комментарии.
Настройки имеют вид

  переменная=значение

Есть два типа настроек. В настройках первого типа значением является строка
символов. Если настройка закомментарена, значение переменной не определено.
Настройка второго типа - это переключатель. Здесь значением может быть
*0* или *1*. Значение `1` означает "включено", а `0` - "выключено". Например,
если вы хотите использовать перловые хуки в `hpt`, задайте

  PERL=1

В противном случае задайте

  PERL=0

Если настройка второго типа закомментарена, это эквивалентно её значению `0`.


2.2 Установка Husky в дистрибутивах Linux c пакетным менеджером rpm
-------------------------------------------------------------------

Для сборки rpm пакетов нужно кроме GNU make и компиляторов установить *mock*.
Mock для сборки использует _chroot_, изолирующий сборочную среду и
гарантирующий воспроизводимость результата. Если в вашем дистрибутиве mock
недоступен, необходимо как минимум установить *rpmbuild*. Применяемый для
установки скрипт будет использовать mock, если он установлен, в противном
случае будет использован rpmbuild.

Для начала установки выполните следующее:

  wget https://raw.githubusercontent.com/huskyproject/huskybse/master/script/init_rpm_build
  chmod 0755 init_rpm_build
  ./init_rpm_build

В результате будет создан каталог `~/husky_build`, а в нём - каталог `husky`.
В этот каталог `husky` будут в дальнейшем скачаны исходники Husky. Но сейчас
нас интересует лежащий в этом каталоге файл `huskymak.rpm.cfg`. Это тот самый
конфигурационный файл сборки, который вам надо просмотреть и, возможно, что-то
в нём изменить. Пожалуйста, обратите внимание, что править надо именно
`huskymak.rpm.cfg`, а не `huskymak.cfg`. Возможно вы заметите, что

  DEBUG=1

Это не ошибка и переделывать на `DEBUG=0` не надо. Современные компиляторы
умеют сочетать компиляцию с возможностью отладки и оптимизацию. В результате
сборки вы получите исполняемые файлы с удалёнными отладочными символами
(stripped), а отладочная информация будет содержаться в отдельном пакете,
который можно будет установить в случае необходимости отладки.

Все описанные выше действия вы выполните только один раз. Теперь можно
запустить сборку:

  ~/husky_build/build_rpm

Результат сборки с использованием `mock` будет в каталоге 
`~/husky_build/result`. При сборке с использованием только `rpmbuild`
результат будет в каталоге `~/rpmbuild/RPMS`.

Если вы использовали рекомендованное значение

  DYNLIBS=0

то имена полученных пакетов будут содержать слово `static`. Это означает,
что была применена частично статическая сборка, при которой библиотеки Husky
были прилинкованы статически, а системные библиотеки - динамические.

В дальнейшем, когда вы узнаете, что в исходный код внесены изменения, и
захотите собрать новую версию, достаточно будет снова запустить

  ~/husky_build/build_rpm

При этом будут скачаны все изменения с гитхаба и будут пересобраны все
пакеты.

Если вы хотите собрать пакеты для другой операционной системы, используя
`mock`, запускайте

  ~/husky_build/build_rpm -r 'CONFIG'

где CONFIG - конфигурация chroot. См. `build_rpm --help` и mock(1).

2.3 Установка Husky в других ОС типа UNIX
-----------------------------------------

Для начала установки выполните следующее:

  wget https://raw.githubusercontent.com/huskyproject/huskybse/master/script/init_build
  chmod 0755 init_build
  ./init_build

Эти команды для Linux. В FreeBSD вместо `wget` запишите `fetch`, остальное то же
самое. В результате будет создан каталог `~/husky`. В этот каталог будут в
дальнейшем скачаны исходники Husky. Но сейчас нас интересует лежащий в этом
каталоге файл `huskymak.cfg`. Это тот самый конфигурационный файл сборки,
который вам надо просмотреть и, возможно, что-то в нём изменить.

Эти действия надо выполнить только один раз. Теперь можно
запустить сборку:

  ./build.sh

После окончания сборки для установки собранных программ в Linux выполните

  sudo make -j install

а в FreeBSD вместо `make` используйте `gmake`. Здесь опция `-j` задаёт
параллельное исполнение. Если вы захотите удалить установленные программы,
в Linux выполните

  sudo make -j uninstall

В FreeBSD используйте `gmake`. Если вы захотите удалить все результаты сборки,
выполните

  make -j distclean           (Linux)
  gmake -j distclean          (FreeBSD)

Но имейте в виду, что если вы удалили все результаты сборки, в следующий раз
придётся повторить всю сборку целиком.

В дальнейшем, когда вы узнаете, что в исходный код внесены изменения, и
захотите собрать новую версию, достаточно будет снова запустить

  ./build.sh

При этом будут скачаны все изменения с гитхаба и будут пересобраны
изменившиеся программы.

Если вы ранее уже скачали исходники с Github в каталог с другим названием,
можно использовать его. В этом случае запускайте `init_build` так:

  ./init_build -d ВАШ_КАТАЛОГ

где `ВАШ_КАТАЛОГ` - название каталога, в котором находятся ваши локальные копии
репозиториев Husky.

3 Установка Husky с мейкфайлами старого образца
===============================================

3.1 Обзор
---------

Помимо стандартного `Makefile`, большинство подпроектов Husky поставляют
дополнительные мейкфайлы с именем `makefile.XXX`, где `XXX` - это суффикс,
зависящий от платформы. Мы называем такие мейкфайлы устаревшими. Если
сравнивать устаревшие мейкфайлы со стандартным, то вот что можно сказать за
и против устаревших мейкфайлов.

За:

  - Вам не нужно редактировать huskymak.cfg, мейкфайлы не имеют
    дополнительной настройки.
  - Поддерживаются многие системы, отличные от UNIX.
  - Вам не нужны ни GNU make, ни gcc, если не указано иное.
  - Иногда они доставляют меньше хлопот, чем стандартный Makefile.

Против:

   - Вы (обычно) не можете ничего установить с помощью этих мейкфайлов. Вы
     несете ответственность за копирование программ, которые вы
     скомпилировали, в соответствующие каталоги.
   - Нет поддержки разделяемых библиотек, все связано статически.
   - Мейкфайлы старого образца не создают файлы `cvsdate.h`, содержащие дату
     последнего изменения исходного кода. Вам надо создавать эти файлы
     самостоятельно.

3.2 Получение исходников
------------------------

Программный проект Husky для Fidonet разделен на несколько подпроектов.
Подпроект - это библиотека или программа. Чтобы скомпилировать любую
программу Husky, вам, по крайней мере, придётся загрузить следующие
подпроекты:

  huskybse      База Husky, содержит инструкции и примеры конфигураций.
  huskylib      Общие объявления и функции для программ Husky.
  smapi         Библиотека API сообщений для Squish и Jam.
  fidoconf      Библиотека Fidoconfig.
  areafix       Библиотека Areafix.

Кроме того, вам нужны программы, которые вы хотите использовать, такие как
`hpt` (тоссер), `htick` (файлэхопроцессор), `msged` (редактор почты) и
другие. Библиотека Areafix нужна только для `hpt` и `htick`. Поскольку
исходники находятся на GitHub, чтобы скачать их, вам понадобится git.
Для любого подпроекта вот команда, чтобы скачать его:

  git clone https://github.com/huskyproject/subproject.git

Здесь `subproject` - это название некоторого подпроекта. Так что,

  mkdir ~/husky
  cd ~/husky
  git clone https://github.com/huskyproject/huskybse.git
  git clone https://github.com/huskyproject/huskylib.git
  git clone https://github.com/huskyproject/smapi.git
  git clone https://github.com/huskyproject/fidoconf.git
  git clone https://github.com/huskyproject/areafix.git
  git clone https://github.com/huskyproject/hpt.git
  git clone https://github.com/huskyproject/htick.git

Команду `git clone` надо использовать только в первый раз. В следующий раз,
когда вы захотите собрать новую версию программ, используйте `git pull` для
обновления исходного кода:

  pushd ИМЯ_ПОДПРОЕКТА
  git pull
  popd

После скачивания исходного кода и после каждого его обновления вам надо
заново создать файлы `cvsdate.h`, содержащие дату последнего изменения
исходного кода. Во всех подпроектах, кроме `hptsqfix`, этот файл лежит
в корневом каталоге подпроекта, а в `hptsqfix` он лежит в подкаталоге `h`.
Содержимое файла `cvsdate.h` имеет следующий вид:

  char cvs_date[]="2021-09-03";

Здесь `2021-09-03` - это пример даты последнего изменения исходного кода
подпроекта в формате ISO 8601. Естественно, дата у вас будет другая. Никаких
пробелов или табуляций в начале строки быть не должно. Дату последнего
изменения исходного кода подпроекта можно получить командой

  git log -1 --date=short --format=format:"%cd" h/*.h src/*.c

Имена каталогов, содержащих файлы `*.h` и `*.c` могут отличаться. Нужно также
учесть даты последнего изменения исходного кода в подпроектах, являющихся
зависимостью данного. Например, `hpt` зависит от `huskylib`, поэтому, если
`huskylib` был изменён позднее `hpt`, то для `hpt` надо взять дату из
`huskylib`. В качестве даты в `cvsdate.h` надо взять максимальную дату
последнего изменения самого подпроекта и всех его зависимостей.

3.3 Список платформ, поддерживаемых мейкфайлами старого образца
----------------------------------------------------------------

Ниже приведён список платформ, поддерживаемых мейкфайлами старого образца.

  Мейкфайл         Платформа Компилятор
  ---------------------------------------------------------------------
  makefile.unx     Unix      Any (standard "cc" is enough!)
  makefile.be      BeOS      BeOS R5 with gcc
  makefile.bsd     BSD       (tested: FreeBSD) GNU gcc
  makefile.lnx     Linux     GNU gcc (2.7..2.95, 3.x)
  makefile.djg     DOS/32    DJ Delorie GNU gcc (DJGPP)
  makefile.cyg     Win32     Mingw32 on Cygwin: http://www.cygwin.com
  makefile.mvc     Win32     Microsoft Visual C
  makefile.mvcdll  Win32     Microsoft Visual C - dll build

  makefile.emo     OS/2      EMX; OMF static (standalone) binaries
  makefile.emx     OS/2      EMX; a.out dynamic (EMXRT) binaries
  makefile.mgw     Win32     Mingw32 or Mingw32/CPD gcc: www.mingw32.org
  makefile.rxw     Win32     EMX/RSXNT gcc with -Zwin32
  makefile.sun     Solaris   GNU gcc
  makefile.wco     OS/2      Watcom C
  makefile.wcw     Win32     Watcom C
  makefile.wcx     DOS/32    Watcom C with DOS extender

  makefile.aix     AIX       IBM xlC
  makefile.bcd     DOS       Borland C / Turbo C (requires TASM)
  makefile.bco     OS/2      Borland C 2.0
  makefile.bcw     Win32     Borland C
  makefile.ibo     OS/2      IBM CSet or VACPP
  makefile.hco     OS/2      Metaware High C
  makefile.osf     TRU64     Compaq CC (or DEC Unix with DEC cc)
  makefile.wcd     DOS       Watcom C
  makefile.qcd     DOS       Quick C / Microsoft MSC 6.0 (req. MASM)

Как правило, если у вас есть ОС Unix с командами `make` и `cc`, вам стоит
сначала попробовать использовать `makefile.unx`. `makefile.unx` - это очень
простой способ сборки всего!

3.4 Компиляция
--------------

Теперь, когда вы выбрали соответствующий мейкфайл, соберите библиотеки
следующим образом (предположим, что вы выбрали файл makefile.unx):

  cd ~/husky/huskylib
  make -f makefile.unx clean
  make -f makefile.unx
  cd ~/husky/smapi
  make -f makefile.unx clean
  make -f makefile.unx
  cd ~/husky/fidoconf
  make -f makefile.unx clean
  make -f makefile.unx
  cd ~/husky/areafix
  make -f makefile.unx clean
  make -f makefile.unx

Затем вы можете напрямую приступить к сборке любого подпроекта следующим
образом:

  cd ~/husky/ИМЯ_ПОДПРОЕКТА
  make -f makefile.unx

Это также работает с системами, отличными от UNIX, например:

  C:
  CD \HUSKY\HUSKYLIB
  imake -f makefile.ibo clean
  imake -f makefile.ibo
  CD \HUSKY\SMAPI
  imake -f makefile.ibo clean
  imake -f makefile.ibo
  CD \HUSKY\FIDOCONF
  imake -f makefile.ibo clean
  imake -f makefile.ibo
  CD \HUSKY\MSGED
  imake -f makefile.ibo clean
  imake -f makefile.ibo

3.5 Установка
-------------

Как уже отмечалось, мейкфайлы старого образца обычно не содержат цели
«install». Следовательно, вам придется «устанавливать» программы вручную,
если вы используете устаревшие мейкфайлы (вам не нужно устанавливать
библиотеки, поскольку программы слинкованы с ними статически). Для
большинства программ Husky установка - это просто копирование исполняемых
файлов в каталог по вашему выбору. Для некоторых других это более сложно, в
частности Msged, где вы также должны установить таблицы перекодирования,
файлы справки и т.д. Пожалуйста, обратитесь к документации отдельных программ
для получения дополнительной информации.

